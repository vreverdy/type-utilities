%% ================== ISO WG21 C++ PROPOSAL: TYPE UTILITIES ================= %%
%% Project:         Type Utilities
%% Name:            p0000_presentation.tex
%% Description:     Type utilities wording draft: presentation
%% Creator:         Vincent Reverdy
%% Contributors:    Vincent Reverdy [2018]
%% License:         BSD 3-Clause License
%% ========================================================================== %%



%% =============================== PARAMETERS =============================== %%
% DOCUMENT PARAMETERS
\newcommand{\docno}{P1016R0}
\newcommand{\prevdocno}{}%{P1016R0}
\newcommand{\doctitle}{A few additional type manipulation utilities}
\newcommand{\docauthor}{Vincent Reverdy}
\newcommand{\doccoauthor}{Robert J. Brunner}
\newcommand{\reldate}{\today}
\newcommand{\firstlibchapter}{language.support}
\newcommand{\lastlibchapter}{thread}
%% ========================================================================== %%



%% ============================== CONFIGURATION ============================= %%
% DOCUMENT TYPE 
\documentclass[8pt]{beamer}

% THEME
\usetheme{Frankfurt}
\useinnertheme{rectangles}
\setbeamertemplate{blocks}[default]

% PACKAGES
%\usepackage{packages/fancylayout}
\usepackage{ragged2e}
\usepackage{multicol}
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage{csquotes}
\usepackage{environ}
\usepackage{stmaryrd}
\usepackage{sistyle}
\usepackage[T1]{fontenc}
\usepackage{pdfpages}
\usepackage{comment}
\usepackage{listings}
\usepackage{makecell}
\usepackage{hyperref}
\usepackage{titling}
\usepackage{tikz}
\usepackage{tikzsymbols}
\usetikzlibrary{calc,positioning,arrows.meta}
\beamertemplatenavigationsymbolsempty

% INFORMATION
\title{\doctitle}
\author{\docauthor}
\date{}

% LISTINGS
\lstset{
    language=C++,
    basicstyle=\ttfamily,
    aboveskip=0pt,
    belowskip=0pt,
    morekeywords={constexpr,noexcept,decltype},
    keywordstyle=\color{blue},
    commentstyle=\color[RGB]{0,128,0},
    showstringspaces=false
}

% NOTEBLOCK
\newcounter{notecounter}
\newenvironment<>{noteblock}[1]{%
\stepcounter{notecounter}%
\setbeamercolor{block title}{fg=white,bg=orange}%
\setbeamercolor{itemize item}{fg=orange!75!yellow}%
\begin{block}#2{#1}}{\end{block}}
%% ========================================================================== %%



%% ================================ DOCUMENT ================================ %%
\begin{document}
%% -------------------------------------------------------------------------- %%
\section*{Introduction}
\subsection{Introduction}
\frame{\titlepage}
%% -------------------------------------------------------------------------- %%
\begin{frame}[fragile]{Summary}
\begin{block}{What?}
\justifying
Additional type traits for the \lstinline{<type_traits>} header and corresponding to common metaprogramming patterns. Originally developed for a library to create custom overload sets (to be proposed separately).\\
\end{block}

\vspace{-0.5\baselineskip}

\begin{block}{Overview}
\justifying
5 domains: pointers removal, qualifiers manipulation, inheritance, callables and helpers.\\
Implementation available at \href{https://github.com/vreverdy/type-utilities}{\texttt{https://github.com/vreverdy/type-utilities}}.
\end{block}

\vspace{-1.5\baselineskip}

\begin{columns}[onlytextwidth, t]
%
\begin{column}{0.18\textwidth}
\begin{exampleblock}{\scriptsize Pointers removal\strut}
\scriptsize\lstinline{remove_all_pointers}
\end{exampleblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{exampleblock}{\scriptsize Qualifiers copy\strut}
\scriptsize\lstinline{copy_const}\linebreak
\scriptsize\lstinline{copy_volatile}\linebreak
\scriptsize\lstinline{copy_cv}\linebreak
\scriptsize\lstinline{copy_reference}\linebreak
\scriptsize\lstinline{copy_signedness}\linebreak
\scriptsize\lstinline{copy_extent}\linebreak
\scriptsize\lstinline{copy_all_extents}\linebreak
\scriptsize\lstinline{copy_pointer}\linebreak
\scriptsize\lstinline{copy_all_pointers}\linebreak
\scriptsize\lstinline{copy_cvref}
\end{exampleblock}
\vspace{-\baselineskip}
\begin{exampleblock}{\scriptsize Qualifiers cloning\strut}
\scriptsize\lstinline{clone_const}\linebreak
\scriptsize\lstinline{clone_volatile}\linebreak
\scriptsize\lstinline{clone_cv}\linebreak
\scriptsize\lstinline{clone_reference}\linebreak
\scriptsize\lstinline{clone_extent}\linebreak
\scriptsize\lstinline{clone_all_extents}\linebreak
\scriptsize\lstinline{clone_pointer}\linebreak
\scriptsize\lstinline{clone_all_pointers}\linebreak
\scriptsize\lstinline{clone_cvref}
\end{exampleblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{exampleblock}{\scriptsize Inheritance\strut}
\scriptsize\lstinline{empty_base}\linebreak
\scriptsize\lstinline{is_instantiable}\linebreak
\scriptsize\lstinline{is_inheritable}\linebreak
\scriptsize\lstinline{inherit_if}
\end{exampleblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{exampleblock}{\scriptsize Callables categorization\strut}
\scriptsize\lstinline{is_closure}\linebreak
\scriptsize\lstinline{is_functor}\linebreak
\scriptsize\lstinline{is_function_object}\linebreak
\scriptsize\lstinline{is_callable}
\end{exampleblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{exampleblock}{\scriptsize Miscellaneous helpers\strut}
\scriptsize\lstinline{index_constant}\linebreak
\scriptsize\lstinline{type_t}\linebreak
\scriptsize\lstinline{false_v}\linebreak
\scriptsize\lstinline{true_v}
\end{exampleblock}
\end{column}
%
\end{columns}

\end{frame}
%% -------------------------------------------------------------------------- %%
\section*{Pointers}
\subsection{Pointers}

\begin{frame}[fragile]{Pointers removal}

\begin{alertblock}{Current pointer and extent transformation traits}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T> struct add_pointer;
template <class T> struct remove_pointer;
template <class T> struct remove_extent;
template <class T> struct remove_all_extents;

template <class T> using add_pointer_t = typename add_pointer<T>::type;
template <class T> using remove_pointer_t = typename remove_pointer<T>::type;
template <class T> using remove_extent_t = typename remove_extent<T>::type;
template <class T> using remove_all_extents_t = typename remove_all_extents<T>::type;
\end{lstlisting}
\end{alertblock}
\vspace{-0.5\baselineskip}
\begin{block}{Synopsis of the proposed additions}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T> struct remove_all_pointers;
template <class T> using remove_all_pointers_t = typename remove_all_pointers<T>::type;
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{block}{Motivations}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Symmetry with \lstinline{remove_extent} and \lstinline{remove_all_extents}
\item As useful as \lstinline{remove_all_extents}
\item Completeness with qualifier manipulation traits (see next section)
\end{itemize}
\vspace{-0.5\baselineskip}
\end{block}
\vspace{-0.5\baselineskip}
\begin{exampleblock}{Example}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Arrays
using arr0_t = int[2][3][4];
using arr1_t = remove_extent_t<arr0_t>;       // int[3][4]
using type_a = remove_all_extents_t<arr0_t>;  // int

// Pointers
using ptr0_t = int***;
using ptr1_t = remove_pointer_t<ptr0_t>;      // int**
using type_p = remove_all_pointers_t<ptr0_t>; // int
\end{lstlisting}
\end{exampleblock}
\end{frame}
%% -------------------------------------------------------------------------- %%
\section*{Qualifiers}
\subsection{Qualifiers}

\begin{frame}[fragile]{Qualifiers manipulation: synopsis}
\vspace{-1.3\baselineskip}
\begin{block}{\vspace*{-3ex}}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class From, class To> struct copy_const;
template <class From, class To> struct clone_const;
template <class From, class To> struct copy_volatile;
template <class From, class To> struct clone_volatile;
template <class From, class To> struct copy_cv;
template <class From, class To> struct clone_cv;
template <class From, class To> struct copy_reference;
template <class From, class To> struct clone_reference;
template <class From, class To> struct copy_signedness;
template <class From, class To> struct copy_extent;
template <class From, class To> struct clone_extent;
template <class From, class To> struct copy_all_extents;
template <class From, class To> struct clone_all_extents;
template <class From, class To> struct copy_pointer;
template <class From, class To> struct clone_pointer;
template <class From, class To> struct copy_all_pointers;
template <class From, class To> struct clone_all_pointers;
template <class From, class To> struct copy_cvref;
template <class From, class To> struct clone_cvref;

template <class F, class T> using copy_const_t = typename copy_const<F, T>::type;
template <class F, class T> using clone_const_t = typename clone_const<F, T>::type;
template <class F, class T> using copy_volatile_t = typename copy_volatile<F, T>::type;
template <class F, class T> using clone_volatile_t = typename clone_volatile<F, T>::type;
template <class F, class T> using copy_cv_t = typename copy_cv<F, T>::type;
template <class F, class T> using clone_cv_t = typename clone_cv<F, T>::type;
template <class F, class T> using copy_reference_t = typename copy_reference<F, T>::type;
template <class F, class T> using clone_reference_t = typename clone_reference<F, T>::type;
template <class F, class T> using copy_signedness_t = typename copy_signedness<F, T>::type;
template <class F, class T> using copy_extent_t = typename copy_extent<F, T>::type;
template <class F, class T> using clone_extent_t = typename clone_extent<F, T>::type;
template <class F, class T> using copy_all_extents_t = typename copy_all_extents<F, T>::type;
template <class F, class T> using clone_all_extents_t = typename clone_all_extents<F, T>::type;
template <class F, class T> using copy_pointer_t = typename copy_pointer<F, T>::type;
template <class F, class T> using clone_pointer_t = typename clone_pointer<F, T>::type;
template <class F, class T> using copy_all_pointers_t = typename copy_all_pointers<F, T>::type;
template <class F, class T> using clone_all_pointers_t = typename clone_all_pointers<F, T>::type;
template <class F, class T> using copy_cvref_t = typename copy_cvref<F, T>::type;
template <class F, class T> using clone_cvref_t = typename clone_cvref<F, T>::type;
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Qualifiers manipulation: design}

\begin{block}{Functionality}
Apply qualifiers or attributes of one type to another type.
\end{block}

\vspace{-0.5\baselineskip}

\begin{exampleblock}{Example}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Copy cv qualifiers
using type0 = copy_cv_t<const int, double>;                 // const double
using type1 = copy_cv_t<volatile int, double>;              // volatile double
using type2 = copy_cv_t<const volatile int, double>;        // const volatile double

// Copy cv-ref qualifiers
using type3 = copy_cvref_t<int&, double>;                   // double&
using type4 = copy_cvref_t<volatile int&, double>;          // volatile double&
using type5 = copy_cvref_t<const volatile int&&, double>;   // const volatile double&&

// Copy vs clone
using type6 = copy_cvref_t<volatile int&, const double>;    // const volatile double&
using type7 = clone_cvref_t<volatile int&, const double>;   // volatile double&
using type8 = copy_all_pointers_t<int**, double***>;        // double*****;
using type9 = clone_all_pointers_t<int**, double***>;       // double**;
\end{lstlisting}
\end{exampleblock}

\vspace{-0.5\baselineskip}

\begin{block}{Design}
\justifying
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Two types of transformations: \lstinline{copy_*} and \lstinline{clone_*}
\item \lstinline{copy_*}: add the given qualifiers/attributes of \lstinline{From} to \lstinline{To}
\item \lstinline{clone_*}: apply the given qualifiers/attributes of \lstinline{From} to \lstinline{To} by first removing the given qualifiers/attributes of \lstinline{To}
\item Same list as existing transformation traits \lstinline{add_*} and \lstinline{remove_*}
\end{itemize}
\vspace{-0.5\baselineskip}
\end{block}

\end{frame}

\begin{frame}[fragile]{Qualifiers manipulation: overview}
\begin{block}{Overview}
\begin{center}
\ttfamily\tiny
\begin{tabular}{@{}|@{\hskip1pt}c@{\hskip1pt}||@{\hskip1pt}c@{\hskip1pt}|@{\hskip1pt}c@{\hskip1pt}|@{\hskip1pt}c@{\hskip1pt}|@{\hskip1pt}c@{\hskip1pt}|@{\hskip1pt}c@{\hskip1pt}|@{\hskip1pt}c@{\hskip1pt}|@{}}
\hline
& \textbf{cv} & \textbf{reference} & \textbf{sign} & \textbf{array} & \textbf{pointer} & \textbf{cvref} \\
\hline
\hline
\textbf{remove\_*} & \makecell{\textcolor{black}{remove\_const} \\ \textcolor{black}{remove\_volatile} \\ \textcolor{black}{remove\_cv}} & \textcolor{black}{remove\_reference} & & \makecell{\textcolor{black}{remove\_extent} \\ \textcolor{black}{remove\_all\_extents}} & \makecell{\textcolor{black}{remove\_pointer} \\ \textcolor{blue}{remove\_all\_pointers}} & \textcolor{black}{remove\_cvref}\\
\hline
\textbf{add\_*} & \makecell{\textcolor{black}{add\_const} \\ \textcolor{black}{add\_volatile} \\ \textcolor{black}{add\_cv}} & \makecell{\textcolor{black}{add\_lvalue\_reference} \\ \textcolor{black}{add\_rvalue\_reference}} & & & \textcolor{black}{add\_pointer} & \\
\hline
\textbf{make\_*} & & & \makecell{\textcolor{black}{make\_signed} \\ \textcolor{black}{make\_unsigned}} & & & \\
\hline
\textbf{copy\_*} & \makecell{\textcolor{blue}{copy\_const} \\ \textcolor{blue}{copy\_volatile} \\ \textcolor{blue}{copy\_cv}} & \textcolor{blue}{copy\_reference} & \textcolor{blue}{copy\_signedness} & \makecell{\textcolor{blue}{copy\_extent} \\ \textcolor{blue}{copy\_all\_extents}} & \makecell{\textcolor{blue}{copy\_pointer} \\ \textcolor{blue}{copy\_all\_pointers}} & \textcolor{blue}{copy\_cvref}\\
\hline
\textbf{clone\_*} & \makecell{\textcolor{blue}{clone\_const} \\ \textcolor{blue}{clone\_volatile} \\ \textcolor{blue}{clone\_cv}} & \textcolor{blue}{clone\_reference} & & \makecell{\textcolor{blue}{clone\_extent} \\ \textcolor{blue}{clone\_all\_extents}} & \makecell{\textcolor{blue}{clone\_pointer} \\ \textcolor{blue}{clone\_all\_pointers}} & \textcolor{blue}{clone\_cvref}\\
\hline
\end{tabular}
\end{center}
\end{block}
\end{frame}

\begin{frame}[fragile]{Qualifiers manipulation: examples}
\vspace{-\baselineskip}
\begin{columns}[onlytextwidth, t]
\begin{column}{0.48\textwidth}
\begin{exampleblock}{Use case: manipulation of universal refs\strut}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T, class U>
void f(T&& x, U&& y) {
    using type = T&&;
    using other = clone_cvref_t<T&&, U&&>;
    /* function contents */
}
\end{lstlisting}
\end{exampleblock}
\vspace{-0.5\baselineskip}
\begin{exampleblock}{Use case: in class templates\strut}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T>
class foo {
    T a;
    copy_cvref_t<T, int> n;
    copy_cvref_t<T, double> x;
    /* class contents */
};
\end{lstlisting}
\end{exampleblock}
\end{column}

\begin{column}{0.48\textwidth}
\begin{exampleblock}{Use case: storing the qualifiers of a type\strut}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
struct placeholder {};

template <class T>
struct qualifiers {
    using type = copy_cvref_t<T, placeholder>;
};

template <class T>
using qualifiers_t
    = typename qualifiers<T>::type;
\end{lstlisting}
\end{exampleblock}
\vspace{-0.5\baselineskip}
\begin{exampleblock}{Use case: C array conversion\strut}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
int array1[5][4][3][2];
using array_type = decltype(array1);
copy_all_extents_t<array_type, double> array2;
\end{lstlisting}
\end{exampleblock}
\end{column}
\end{columns}

\begin{exampleblock}{Use case: \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0847r0.html}{P0847R0}: Deducing this\strut}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Example provided in P0847R0
template <class From, class To> using like_t = clone_cvref_t<From, To>;

struct B {
    template <typename Self>
    auto&& f(Self&& this self) {
        return forward<Self>(*this).i;              // ok if Self and *this are the same type
                                                    // compile other if Self is a derived type
        return forward<like_t<Self, B>>(*this).i;   // always ok
        return forward_like<Self>(*this).i;         // always ok
    }
};
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Qualifiers manipulation: about signedness}
\vspace{-0.5\baselineskip}
\begin{alertblock}{Current sign manipulators}
\justifying
\vspace{-0.5\baselineskip}
\begin{itemize}
\item \lstinline{make_signed}
\item \lstinline{make_unsigned}
\item \lstinline{is_same_v<char, signed char>} and \lstinline{is_same_v<char, unsigned char>} are both \lstinline{false}: therefore, contrarily to other integral types once \lstinline{make_signed} or \lstinline{make_unsigned} has been applied to \lstinline{char} it is impossible to recover it easily (a \lstinline{remove_sign} trait would be necessary)
\end{itemize}
\vspace{-0.5\baselineskip}
\end{alertblock}
\vspace{-0.5\baselineskip}
\begin{exampleblock}{Proposed behavior}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
using type0 = copy_signedness_t<unsigned int, char>;            // unsigned char
using type1 = copy_signedness_t<signed int, char>;              // signed char
using type2 = copy_signedness_t<char, unsigned int>;            // unsigned int
using type3 = copy_signedness_t<unsigned char, unsigned int>;   // unsigned int
using type4 = copy_signedness_t<signed char, unsigned int>;     // signed int
using type5 = copy_signedness_t<char, unsigned char>;           // unsigned char

// using type6 = clone_signedness_t<char, unsigned char>;       // char (hypothetical)

using type7 = copy_signedness_t<signed char, unsigned int>;
// is equivalent to "make_signed_t<unsigned int>" since "signed unsigned int" would not compile
\end{lstlisting}
\end{exampleblock}
\vspace{-0.5\baselineskip}
\end{frame}

\begin{frame}[fragile]{Qualifiers manipulation: discussion and open questions}
\begin{noteblock}{Bikeshedding}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Alternative names for \lstinline{copy_*}?
\item Alternative names for \lstinline{clone_*}?
\item Alternative names for \lstinline{copy_signedness}?
\end{itemize}
\vspace{-0.5\baselineskip}
\end{noteblock}
\vspace{-0.5\baselineskip}
\begin{noteblock}{Remarks on \texttt{copy\_reference}}
\lstinline{copy_reference_t<T&, U&>}, \lstinline{copy_reference_t<T&&, U&>}, \lstinline{copy_reference_t<T&, U&&>} and \lstinline{copy_reference_t<T&&, U&&>} use reference collapsing rules to compute the resulting type. As \lstinline{clone_reference} first removes the ref-qualifier of the second type, there is no need for reference collapsing in this case.
\end{noteblock}
\vspace{-0.5\baselineskip}
\begin{noteblock}{Remarks on \texttt{copy\_pointer}}
\justifying
\lstinline{copy/clone_pointer} and \lstinline{copy/clone_all_pointer} copy cv-qualification of pointers:
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
using type = int* const* volatile** const volatile*;
using other = copy_all_pointers_t<type, double>; // double* const* volatile** const volatile*
\end{lstlisting}
\end{noteblock}
\vspace{-0.5\baselineskip}
\begin{noteblock}{Remarks on \texttt{copy\_signedness}}
\justifying
\vspace{-0.5\baselineskip}
\begin{itemize}
\item \lstinline{clone_signedness} is not introduced because \lstinline{remove_sign} does not exist
\item The name \lstinline{copy_signedness} is chosen because \lstinline{copysign} already exists
\item \lstinline{copy_signedness} does not add a sign keyword (contrarily to the others \lstinline{copy_*}) but uses \lstinline{make_signed} and \lstinline{make_unsigned} instead
\end{itemize}
\vspace{-0.5\baselineskip}
\end{noteblock}
\end{frame}
%% -------------------------------------------------------------------------- %%
\section*{Inheritance}
\subsection{Inheritance}

\begin{frame}[fragile]{Inheritance: summary}
\vspace{-0.5\baselineskip}
\begin{block}{Synopsis of the proposed additions}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class... T> struct empty_base;
template <class T> struct is_instantiable;
template <class T> struct is_inheritable;
template <bool b, class T> struct inherit_if;

template <class T> inline constexpr bool is_instantiable_v = is_instantiable<T>::value;
template <class T> inline constexpr bool is_inheritable_v = is_inheritable<T>::value;
template <bool b, class T> using inherit_if_t = typename inherit_if<b, T>::type;
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{block}{\texttt{empty\_base}: a general purpose templated empty base class}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class... T> struct empty_base {};
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{block}{\texttt{is\_instantiable}: to check if it is possible to instantiate an object of type \lstinline{T}}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T> struct is_instantiable: bool_constant</* TBD */> {};
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{block}{\texttt{is\_inheritable}: to check if it is possible to inherit from a class}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T> struct is_inheritable: bool_constant<is_class_v<T> && !is_final_v<T>> {};
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{block}{\texttt{inherit\_if}: to enable the conditional inheritance pattern}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <bool b, class T> struct inherit_if {using type = conditional_t<b, T, empty_base<T>>;};
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{exampleblock}{\texttt{inherit\_if}: use case}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Inherit if possible
template <class T> struct foo: inherit_if_t<is_inheritable_v<T>, T> {/* class contents */};

// Inheritance based on the properties of T
template <class T> struct bar: inherit_if_t<is_integral_v<T>, foo<T>> {/* class contents */};
\end{lstlisting}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Inheritance: discussion and open questions}
\begin{noteblock}{Bikeshedding}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Alternative names for \lstinline{empty_base}?
\item Alternative names for \lstinline{is_instantiable}?
\item Alternative names for \lstinline{is_inheritable}?
\item Alternative names for \lstinline{inherit_if}?
\end{itemize}
\vspace{-0.5\baselineskip}
\end{noteblock}

\begin{noteblock}{Remarks on \texttt{empty\_base}: need for a standardized empty class}
\justifying
3 mains options:
\begin{itemize}
\item \lstinline{blank}: introduce a new empty class to become the standardized universal empty class for metaprogramming (the name being inspired from \href{https://www.boost.org/doc/libs/1_66_0/boost/blank.hpp}{The Boost C++ Libraries})
\item \lstinline{monostate}: make \lstinline{monostate} the standardized universal empty class (in that case it should be put in \lstinline{<utility>} or \lstinline{<type_traits>} instead of \lstinline{<variant>})
\item \lstinline{empty_base}: introduce a specialized empty class in the context of conditional inheritance so that \lstinline{inherit_if_t} corresponds to \lstinline{conditional_t<b, T, empty_base<T>>}
\end{itemize}
\vspace{-0.5\baselineskip}
\end{noteblock}

\begin{noteblock}{Remarks on \texttt{is\_instantiable}}
\justifying
What should the exact definition be?
\end{noteblock}

\end{frame}
%% -------------------------------------------------------------------------- %%
\section*{Callables}
\subsection{Callables}

\begin{frame}[fragile]{Callables categorization: summary}

\begin{alertblock}{Current traits related to callables}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T> struct is_function;
template <class T> struct is_member_function_pointer;
template <class T> struct is_member_object_pointer;

template <class Fn, class... ArgTypes> struct is_invocable;
template <class R, class Fn, class... ArgTypes> struct is_invocable_r;
template <class Fn, class... ArgTypes> struct is_nothrow_invocable;
template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;
template <class Fn, class... ArgTypes> struct invoke_result;
template <class F, class... A> invoke_result_t<F, A...> invoke(F&& f, A&&... a) noexcept(/*..*/);
\end{lstlisting}
\end{alertblock}

\begin{block}{Synopsis of the proposed additions}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T> struct is_closure;
template <class T> struct is_functor;
template <class T> struct is_function_object;
template <class T> struct is_callable;

template <class T> inline constexpr bool is_closure_v = is_closure<T>::value;
template <class T> inline constexpr bool is_functor_v = is_functor<T>::value;
template <class T> inline constexpr bool is_function_object_v = is_function_object<T>::value;
template <class T> inline constexpr bool is_callable_v = is_callable<T>::value;
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Callables categorization: motivations}
\begin{block}{Main motivations}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Make the custom overload set proposal possible (to be proposed separately)
\item Detect types that are already defined in the standard but do not have traits yet
\item Complete existing traits such as \lstinline{is_function} and \lstinline{is_member_function_pointer}
\item Have a trait associated with the concept satisfied by the first argument of \lstinline{invoke} (suggested by \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html}{P0604R0: Resolving GB 55, US 84, US 85, US 86} but left for later)
\item Distinguish between the different categories of callable types
\end{itemize}
\end{block}
\vspace{-0.5\baselineskip}
\begin{exampleblock}{Examples of use cases}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Definition and use of the callable concept
template <class T>
concept Callable = is_callable_v<T>::value;
template <Callable F, class... Args>
invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) noexcept(/*...*/);

// Inheriting from a functor
template <class F, class = void> class functor;
template <class F>
class functor<F, enable_if_t<is_functor_v<F> && is_inheritable_v<F>>>
: F {public: using F::operator(); /* Only working for an inheritable functor */};

// Check if a template class will have a unique key
template <class T, class Key>
struct wrapper {
    using key_t = Key;
    template <class T> constexpr wrapper(const T& value, const Key& key) {}
};
wrapper(4, []{});
constexpr bool b = is_closure_v<typename decltype(wrapper)::key_t>;
\end{lstlisting}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Callables categorization: definitions}

\begin{block}{Existing definition of a closure type [expr.prim.lambda.closure]}
\justifying
The type of a lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type, called the \textbf{closure type}, whose properties are described below. [...]
\end{block}

\begin{block}{Existing definition of a function object type [function.objects]}
\justifying
A \textbf{function object type} is an object type that can be the type of the postfix-expression in a function call. A function object is an object of a function object type.
\end{block}

\begin{block}{Existing definition of a callable type [func.def]}
\justifying
The following definitions apply to this Clause:
\begin{itemize}
\item A call signature is the name of a return type followed by a parenthesized comma-separated list of zero or more argument types
\item A \textbf{callable type} is a function object type or a pointer to member
\item A callable object is an object of a callable type
\item A call wrapper type is a type that holds a callable object and supports a call operation that forwards to that object
\item A call wrapper is an object of a call wrapper type
\item A target object is the callable object held by a call wrapper
\end{itemize}
\vspace{-0.5\baselineskip}
\end{block}

\end{frame}

\begin{frame}[fragile]{Callables categorization: function objects and functors}

\begin{block}{Definition of function objects and functors [\href{https://en.wikipedia.org/wiki/Function_object}{Wikipedia}]}
\justifying
In computer programming, a \textbf{function object} is a construct allowing an object to be invoked or called as if it were an ordinary function, usually with the same syntax (a function parameter that can also be a function). Function objects are often called \textbf{functors}.
\end{block}
\vspace{-0.5\baselineskip}
\begin{alertblock}{In C++ pointers to functions are of function object types}
\justifying
``A \textbf{function object type} is an object type that can be the type of the postfix-expression in a function call.'' Since that for a type \lstinline{P} such that \lstinline{is_pointer_v<P>} evaluates to \lstinline{true}, \lstinline{is_object_v<P>} also evaluates to \lstinline{true}, and since pointers to functions can be of the type of the postfix-expression in a function call, pointers to functions are considered to be of function object types. 
\end{alertblock}
\vspace{-0.5\baselineskip}
\begin{alertblock}{Misleading for non-expert users}
\justifying
As observed on \href{https://stackoverflow.com/q/49503229}{StackOverflow}, this is very misleading for non-expert users: they would expect function object types to be class types with an overloaded \lstinline{operator()}.
\end{alertblock}
\vspace{-0.5\baselineskip}
\begin{block}{Introducing a functor trait}
\justifying
A type trait \lstinline{is_functor} is introduced on the top of \lstinline{is_function_object}:
\begin{itemize}
\item \lstinline{is_functor}: a (possibly union) class type with an overloaded \lstinline{operator()}
\item \lstinline{is_function_object}: an object type that can be the type of the postfix-expression in a function call [function.objects]
\end{itemize}
\vspace{-0.5\baselineskip}
\end{block}
\end{frame}

\begin{frame}[fragile]{Callables categorization: discussion and open questions}

\begin{noteblock}{Remarks on \texttt{is\_functor}}
\justifying
Should only public overloads of \lstinline{operator()} be considered, or also protected and private ones?
\end{noteblock}

\begin{noteblock}{Remarks on \texttt{is\_callable}}
\justifying
Should references to callables be also considered as callables?
\end{noteblock}

\end{frame}
%% -------------------------------------------------------------------------- %%
\section*{Helpers}
\subsection{Helpers}

\begin{frame}[fragile]{Miscellaneous helpers: summary}

\begin{alertblock}{Current helpers related to the new ones}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Integral constant and integer sequence
template<class T, T v> struct integral_constant;
template<bool B> using bool_constant = integral_constant<bool, B>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

// Integer sequence
template<class T, T...> struct integer_sequence;
template<size_t... I> using index_sequence = integer_sequence<size_t, I...>;
template<class T, T N> using make_integer_sequence = integer_sequence<T, see below >;
template<size_t N> using make_index_sequence = make_integer_sequence<size_t, N>;
template<class... T> using index_sequence_for = make_index_sequence<sizeof...(T)>;

// SFINAE
template<class...> using void_t = void;
\end{lstlisting}
\end{alertblock}
\vspace{-0.5\baselineskip}
\begin{block}{Synopsis of the proposed additions}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <size_t I> using index_constant = integral_constant<size_t, I>;
template <class T, class...> using type_t = T;
template <class...> inline constexpr bool false_v = false;
template <class...> inline constexpr bool true_v = true;
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{block}{Motivations for \texttt{index\_constant}}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Symmetry of \lstinline{integral_constant} with \lstinline{integer_sequence} and \lstinline{index_sequence}
\item As useful as \lstinline{index_sequence} since specifying a type corresponding to a constant size is a common need
\end{itemize}
\vspace{-0.5\baselineskip}
\end{block}

\end{frame}

\begin{frame}[fragile]{Miscellaneous helpers: \texttt{false\_v} and \texttt{true\_v}}
\begin{block}{Motivations for \texttt{false\_v} and \texttt{true\_v}}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Avoid hard errors in template dependent contexts
\item Example of use with \lstinline{static_assert}
\end{itemize}
\vspace{-0.5\baselineskip}
\end{block}
\vspace{-0.5\baselineskip}

\begin{exampleblock}{Use case for \texttt{false\_v}}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Example provided by Arthur O'Dwyer
template<class OuterAlloc, class... InnerAllocs>
class scoped_allocator_adaptor {
    public:
    using oalloc_t = OuterAlloc;
    using ialloc_t = scoped_allocator_adaptor<InnerAllocs...>;

    private:
    oalloc_t _outer;
    ialloc_t _inner;
    using _otraits = allocator_traits<OuterAlloc>;

    public:
    template<class... Args>
    void construct(value_type* p, Args&&... args) {
        if constexpr (!uses_allocator_v<value_type, ialloc_t>) {
            _otraits::construct(_outer, p, forward<Args>(args)...);
        } else if constexpr (is_constructible_v<value_type, alloc_arg_t, ialloc_t, Args&&...>) {
            _otraits::construct(_outer, p, allocator_arg, _inner, forward<Args>(args)...);
        } else if constexpr (is_constructible_v<value_type, Args&&..., ialloc_t&>) {
            _otraits::construct(_outer, p, forward<Args>(args)..., _inner);
        } else {
            // static_assert(false, "value_type is not constructible from args"); // not working
            static_assert(false_v<Args&&...>, "value_type is not constructible from args");
        }
    }
};
\end{lstlisting}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Miscellaneous helpers: \texttt{type\_t}}

\begin{block}{Complements to \texttt{void\_t}: the logic behind it}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
// Link between type_t, void_t, false_v and true_v
template <class T, class...> using type_t = T;
template <class... Ts> using void_t = type_t<void, Ts...>;
template <class... Ts> inline constexpr bool false_v = type_t<false_type, Ts...>::value;
template <class... Ts> inline constexpr bool true_v = type_t<true_type, Ts...>::value;
\end{lstlisting}
\end{block}
\vspace{-0.5\baselineskip}
\begin{block}{Motivations for \texttt{type\_t}}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Simple generalization of \lstinline{void_t}
\item Useful to combine SFINAE with the return of a type
\item Powerful when combined with the custom overload set proposal
\end{itemize}
\vspace{-0.5\baselineskip}
\end{block}
\vspace{-0.5\baselineskip}
\begin{exampleblock}{Basic use case of \texttt{type\_t}}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
template <class T, class U> struct foo;
template <class T, class U> struct foo<T, type_t<U, decltype(declval<T>() + declval<U>())>> {
    static constexpr auto value = "declval<T>() + declval<U>()";
};
template <class T, class U> struct foo<T, type_t<U, decltype(declval<T>().size())>> {
    static constexpr auto value = "declval<T>().size()";
};
int main() {
    cout << foo<double, int>::value << endl; // declval<T>() + declval<U>()
    cout << foo<string, int>::value << endl; // declval<T>().size()
}
\end{lstlisting}
\end{exampleblock}
\vspace{-0.5\baselineskip}
\begin{noteblock}{Bikeshedding}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Alternative names for \lstinline{type_t}?
\item Alternative names for \lstinline{false_v} and \lstinline{true_v}?
\end{itemize}
\vspace{-0.5\baselineskip}
\end{noteblock}
\end{frame}
%% -------------------------------------------------------------------------- %%
\section*{Conclusion}
\subsection{Conclusion}

\begin{frame}[fragile]{Conclusion: overview of design decisions}
\vspace{-0.5\baselineskip}

\begin{noteblock}{Bikeshedding}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item Alternative names for \lstinline{copy_*}?
\item Alternative names for \lstinline{clone_*}?
\item Alternative names for \lstinline{copy_signedness}?
\item Alternative names for \lstinline{empty_base}?
\item Alternative names for \lstinline{is_instantiable}?
\item Alternative names for \lstinline{is_inheritable}?
\item Alternative names for \lstinline{inherit_if}?
\item Alternative names for \lstinline{type_t}?
\item Alternative names for \lstinline{false_v} and \lstinline{true_v}?
\end{itemize}
\vspace{-0.5\baselineskip}
\end{noteblock}

\vspace{-0.5\baselineskip}

\begin{noteblock}{Main open questions and remarks}
\vspace{-0.5\baselineskip}
\begin{itemize}
\item \lstinline{copy/clone_pointer} and \lstinline{copy/clone_all_pointer}: copy cv-qualification
\item \lstinline{copy_signedness} does not add a sign keyword (contrarily to the others \lstinline{copy_*}) but uses \lstinline{make_signed} and \lstinline{make_unsigned} instead
\item \lstinline{clone_signedness} is not introduced because \lstinline{remove_sign} does not exist
\item \lstinline{blank} vs \lstinline{monostate} vs \lstinline{empty_base}: need for an empty class
\item \lstinline{is_instantiable}: what should the exact definition be?
\item \lstinline{is_functor}: should only public overloads of \lstinline{operator()} be considered?
\item \lstinline{is_callable}: should references to callables be also considered as callables?
\end{itemize}
\vspace{-0.5\baselineskip}
\end{noteblock}

\end{frame}

\begin{frame}[fragile]{Conclusion: overview of functionalities}

\vspace{-0.5\baselineskip}

\begin{center}
\ttfamily\tiny
\begin{tabular}{|l|c|c|c|c|c|}
\hline
& SF & F & N & A & SA\\
\hline
remove\_all\_pointers & & & & &\\
\hline
copy\_*/clone\_* & & & & &\\
\hline
copy\_signedness & & & & &\\
\hline
empty\_base & & & & &\\
\hline
is\_instantiable & & & & &\\
\hline
is\_inheritable & & & & &\\
\hline
inherit\_if & & & & &\\
\hline
is\_closure & & & & &\\
\hline
is\_functor & & & & &\\
\hline
is\_function\_object & & & & &\\
\hline
is\_callable & & & & &\\
\hline
index\_constant & & & & &\\
\hline
type\_t & & & & &\\
\hline
false\_v/true\_v & & & & &\\
\hline
\end{tabular}
\end{center}

\vspace{-1\baselineskip}

\begin{columns}[onlytextwidth, t]
%
\begin{column}{0.18\textwidth}
\begin{noteblock}{\scriptsize Pointers removal\strut}
\scriptsize\lstinline{remove_all_pointers}
\end{noteblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{noteblock}{\scriptsize Qualifiers copy\strut}
\scriptsize\lstinline{copy_const}\linebreak
\scriptsize\lstinline{copy_volatile}\linebreak
\scriptsize\lstinline{copy_cv}\linebreak
\scriptsize\lstinline{copy_reference}\linebreak
\scriptsize\lstinline{copy_signedness}\linebreak
\scriptsize\lstinline{copy_extent}\linebreak
\scriptsize\lstinline{copy_all_extents}\linebreak
\scriptsize\lstinline{copy_pointer}\linebreak
\scriptsize\lstinline{copy_all_pointers}\linebreak
\scriptsize\lstinline{copy_cvref}
\end{noteblock}
\vspace{-\baselineskip}
\begin{noteblock}{\scriptsize Qualifiers cloning\strut}
\scriptsize\lstinline{clone_const}\linebreak
\scriptsize\lstinline{clone_volatile}\linebreak
\scriptsize\lstinline{clone_cv}\linebreak
\scriptsize\lstinline{clone_reference}\linebreak
\scriptsize\lstinline{clone_extent}\linebreak
\scriptsize\lstinline{clone_all_extents}\linebreak
\scriptsize\lstinline{clone_pointer}\linebreak
\scriptsize\lstinline{clone_all_pointers}\linebreak
\scriptsize\lstinline{clone_cvref}
\end{noteblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{noteblock}{\scriptsize Inheritance\strut}
\scriptsize\lstinline{empty_base}\linebreak
\scriptsize\lstinline{is_instantiable}\linebreak
\scriptsize\lstinline{is_inheritable}\linebreak
\scriptsize\lstinline{inherit_if}
\end{noteblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{noteblock}{\scriptsize Callables categorization\strut}
\scriptsize\lstinline{is_closure}\linebreak
\scriptsize\lstinline{is_functor}\linebreak
\scriptsize\lstinline{is_function_object}\linebreak
\scriptsize\lstinline{is_callable}
\end{noteblock}
\end{column}
%
\begin{column}{0.18\textwidth}
\begin{noteblock}{\scriptsize Miscellaneous helpers\strut}
\scriptsize\lstinline{index_constant}\linebreak
\scriptsize\lstinline{type_t}\linebreak
\scriptsize\lstinline{false_v}\linebreak
\scriptsize\lstinline{true_v}
\end{noteblock}
\end{column}
%
\end{columns}

\end{frame}

\begin{frame}
\vfill
\centering
\begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}Thank you for your attention\par%
\end{beamercolorbox}
\vfill  
\end{frame}
%% -------------------------------------------------------------------------- %%
\end{document}
%% ========================================================================== %%
